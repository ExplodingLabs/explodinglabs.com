{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>SuperStack is a lightweight, modular backend powered by PostgreSQL \u2014 perfect for indie developers, SaaS builders, and teams who want full rontrol without the bloat.</p> <p>Spin up a fully working backend in seconds, with zero setup. Just clone and run.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks locally</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Getting Started</li> <li>Migrations</li> <li>Postgres Extensions</li> <li>Authentication</li> <li>Psql</li> <li>Deploying to Remote Environments</li> </ul>"},{"location":"authentication/","title":"\ud83d\udd10 Authentication","text":"<p>SuperStack includes everything you need to implement secure, JWT-based authentication using PostgreSQL functions.</p>"},{"location":"authentication/#1-install-pgjwt","title":"\ud83d\udce6 1. Install pgjwt","text":"<p>To enable JWT signing inside Postgres, you\u2019ll need to install the pgjwt extension.</p>"},{"location":"authentication/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/michelp/pgjwt postgres/pgjwt\n</code></pre>"},{"location":"authentication/#update-your-dockerfile","title":"Update Your Dockerfile","text":"<p>Edit <code>postgres/Dockerfile</code> to build and install the extension:</p> <pre><code>RUN apt-get update &amp;&amp; apt-get install -y \\\n build-essential \\\n postgresql-server-dev-17\n\n# pgjwt - used by auth schema\nCOPY ./pgjwt /pgjwt\nWORKDIR /pgjwt\nRUN make &amp;&amp; make install\n\nWORKDIR /var/lib/postgresql\n</code></pre> <p>Then rebuild:</p> <pre><code>docker compose build postgres\n</code></pre>"},{"location":"authentication/#2-add-migrations","title":"\u27a1\ufe0f 2. Add Migrations","text":""},{"location":"authentication/#load-required-extensions","title":"\ud83d\udcda Load Required Extensions","text":"<p>Add this to a migration file like <code>01-extensions.sql</code>:</p> <pre><code>-- pgcrypto adds public.crypt used in auth.encrypt_pass\ncreate extension pgcrypto;\n\n-- pgjwt adds public.sign used in auth.generate_access_token\ncreate extension pgjwt;\n</code></pre> <p>\u26a0\ufe0f Do not wrap this file in a <code>BEGIN/COMMIT</code> block \u2014 <code>create extension</code> is non-transactional.</p>"},{"location":"authentication/#create-the-auth-schema","title":"\ud83c\udfd7 Create the Auth Schema","text":"<p>Create a new migration file, e.g. <code>02-create_auth_schema.sql</code>.</p> Click to view file <pre><code>-- 02-create_auth_schema.sql\nbegin;\n\n-- Create auth schema and tables\ncreate schema auth;\n\ncreate table auth.user (\n  username text primary key check (length(username) &gt;= 3),\n  password text not null check (length(password) &lt; 512),\n  role name not null check (length(role) &lt; 512)\n);\n\ncreate table auth.refresh_token (\n  id bigint generated always as identity primary key,\n  created_at timestamp not null default now(),\n  token text,\n  username text\n);\n\n-- Enforce that roles exist in pg_roles\ncreate function auth.check_role_exists() returns trigger\nlanguage plpgsql as $$\nbegin\n  if not exists (select 1 from pg_roles where rolname = new.role) then\n    raise foreign_key_violation using message = 'unknown database role: ' || new.role;\n    return null;\n  end if;\n  return new;\nend\n$$;\n\ncreate constraint trigger ensure_user_role_exists\nafter insert or update on auth.user\nfor each row execute procedure auth.check_role_exists();\n\n-- Encrypt passwords on insert/update\ncreate function auth.encrypt_pass() returns trigger\nlanguage plpgsql as $$\nbegin\n  if tg_op = 'INSERT' or new.password &lt;&gt; old.password then\n    new.password := crypt(new.password, gen_salt('bf'));\n  end if;\n  return new;\nend\n$$;\n\ncreate trigger encrypt_pass\nbefore insert or update on auth.user\nfor each row execute procedure auth.encrypt_pass();\n\n-- Generate JWT access tokens\ncreate function auth.generate_access_token(\n  role_ text, user_ text, secret text\n) returns text\nlanguage plpgsql as $$\ndeclare\n  access_token text;\nbegin\n  select public.sign(row_to_json(r), secret) into access_token from (\n    select role_ as role, user_ as username,\n      extract(epoch from now())::integer + 600 as exp\n  ) r;\n  return access_token;\nend;\n$$;\n\n-- Login endpoint\ncreate function auth.login(user_ text, pass text) returns void\nlanguage plpgsql security definer as $$\ndeclare\n  access_token text;\n  headers text;\n  refresh_token text;\n  role_ name;\nbegin\n  select role into role_\n  from auth.user\n  where username = user_\n    and password = public.crypt(pass, password);\n\n  if role_ is null then\n    raise sqlstate 'PT401' using message = 'Invalid user or password';\n  end if;\n\n  select auth.generate_access_token(role_, user_, current_setting('pgrst.jwt_secret')) into access_token;\n\n  refresh_token := public.gen_random_uuid();\n  insert into auth.refresh_token (token, username) values (refresh_token, user_);\n\n  headers := '[' ||\n    '{\"Set-Cookie\": \"access_token=' || access_token || '; Path=/; HttpOnly;\"},' ||\n    '{\"Set-Cookie\": \"refresh_token=' || refresh_token || '; Path=/rpc/refresh_token; HttpOnly;\"}' ||\n  ']';\n  perform set_config('response.headers', headers, true);\nend;\n$$;\n\n-- Logout endpoint\ncreate function auth.logout() returns void\nlanguage plpgsql security definer as $$\ndeclare headers text;\nbegin\n  headers := '[' ||\n    '{\"Set-Cookie\": \"access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT;\"},' ||\n    '{\"Set-Cookie\": \"refresh_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT;\"}' ||\n  ']';\n  perform set_config('response.headers', headers, true);\nend;\n$$;\n\n-- Refresh token endpoint\ncreate function auth.refresh_token() returns void\nlanguage plpgsql security definer as $$\ndeclare\n  user_ text;\n  access_token text;\n  headers text;\n  refresh_token_ text;\n  role_ text;\nbegin\n  refresh_token_ := current_setting('request.cookies', true)::json-&gt;&gt;'refresh_token';\n\n  select username into user_\n  from auth.refresh_token\n  where token = refresh_token_\n    and created_at &gt; now() - interval '30 days';\n\n  if user_ is null then\n    raise sqlstate 'PT401' using message = 'Invalid or expired refresh token';\n  end if;\n\n  select role into role_ from auth.user where username = user_;\n  if role_ is null then\n    raise sqlstate 'PT401' using message = 'Unknown user';\n  end if;\n\n  select auth.generate_access_token(role_, user_, current_setting('pgrst.jwt_secret')) into access_token;\n\n  headers := '[{\"Set-Cookie\": \"access_token=' || access_token || '; Path=/; HttpOnly;\"}]';\n  perform set_config('response.headers', headers, true);\nend;\n$$;\n\ncommit;\n</code></pre>"},{"location":"authentication/#grant-permissions","title":"\ud83d\udc6e Grant Permissions","text":"<p>Add another migration such as <code>99-roles_and_grants.sql</code>:</p> <pre><code>begin;\n\ngrant usage on schema auth to anon;\ngrant execute on function auth.login(text, text) to anon;\ngrant execute on function auth.logout() to anon;\ngrant execute on function auth.refresh_token() to anon;\n\ncommit;\n</code></pre>"},{"location":"authentication/#3-run-the-migrations","title":"\u25b6\ufe0f 3. Run the Migrations","text":"<p>Once your migrations are ready:</p> <pre><code>bin/postgres migrate\n</code></pre> <p>SuperStack will execute the new migration files and skip those already applied.</p>"},{"location":"authentication/#4-add-the-auth-schema-to-postgrest","title":"4. Add the Auth Schema to PostgREST","text":"<p>Add the auth schema to Postgres in <code>compose.yaml</code>:</p> <pre><code>PGRST_DB_SCHEMAS: api,auth\n</code></pre> <p>\u2705 Usage</p> <p>Explain that all auth endpoints must have a certain header.</p> <p>Show example of using each endpoint.</p> <ul> <li>POST-ing a user.</li> <li><code>/rpc/login</code></li> <li><code>/rpc/logout</code></li> <li><code>/rpc/refresh_token</code></li> </ul>"},{"location":"deploying/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployment is simple and portable. Here's how to deploy it to a remote server.</p>"},{"location":"deploying/#1-set-your-image-names","title":"\u2705 1. Set Your Image Names","text":"<p>In <code>compose.yaml</code>, change the image names to your own (e.g. using your Docker Hub or GitHub Container Registry account):</p> <p>For example:</p> <pre><code>postgres:\n  image: ghcr.io/youruser/yourapp-postgres\n</code></pre>"},{"location":"deploying/#2-build-and-push-the-images","title":"\ud83d\udee0\ufe0f 2. Build and Push the Images","text":"<p>Build locally and push to your registry:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploying/#3-deploy-the-compose-file","title":"\ud83d\udce6 3. Deploy the Compose File","text":"<p>Only <code>compose.yaml</code> is required on the server. Copy it over:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploying/#4-launch-superstack-on-the-server","title":"\ud83d\ude80 4. Launch SuperStack on the Server","text":"<p>SSH into your server and run:</p> <pre><code>docker compose up -d\n</code></pre> <p>That\u2019s it \u2014 your backend is live.</p>"},{"location":"deploying/#environment-variables","title":"\ud83d\udd10 Environment Variables","text":"<p>For production, avoid using <code>.env</code> files. Instead, set secrets directly:</p> <pre><code>CADDY_PORT=80 \\\nPG_USER=admin \\\nPG_PASS=supersecret \\\nPOSTGREST_AUTHENTICATOR_PASS=supersecret \\\nJWT_SECRET=your-secret \\\ndocker compose up -d\n</code></pre> <p>\ud83d\udca1 Avoid leaking secrets by disabling shell history. Alternatively, use environment injection in your CI/CD.</p>"},{"location":"deploying/#upgrading-remote-environments","title":"\ud83d\udd04 Upgrading Remote Environments","text":"<p>When you release changes \u2014 like new migrations or updated images \u2014 you can upgrade your remote stack in two simple steps.</p>"},{"location":"deploying/#1-pull-the-latest-images","title":"1. Pull the Latest Images","text":"<p>On the remote server, run:</p> <pre><code>docker compose pull\n</code></pre> <p>This fetches the latest versions of your tagged images (as defined in <code>compose.yaml</code>).</p>"},{"location":"deploying/#2-apply-any-new-migrations","title":"2. Apply Any New Migrations","text":"<p>Then run your migration script inside the running Postgres container:</p> <pre><code>bin/postgres migrate\n</code></pre> <p>This ensures your database schema is up to date.</p>"},{"location":"deploying/#3-restart-the-stack-if-needed","title":"3. Restart the Stack (if needed)","text":"<p>If you\u2019ve made changes to service definitions or image tags:</p> <pre><code>docker compose up -d\n</code></pre> <p>Docker Compose will only restart containers if something changed.</p>"},{"location":"extensions/","title":"\ud83e\udde9 Postgres Extensions","text":"<p>SuperStack supports PostgreSQL extensions, letting you add powerful features like cryptographic functions or JWT handling.</p>"},{"location":"extensions/#loading-a-built-in-extension","title":"\ud83d\udd0c Loading a Built-In Extension","text":"<p>To load a standard extension (like pgcrypto), create a migration file such as:</p> <pre><code>-- File: postgres/migrations/01-extensions.sql\n\ncreate extension pgcrypto;\n</code></pre> <p>\u26a0\ufe0f <code>create extension</code> is non-transactional, so don\u2019t wrap this file in <code>BEGIN/COMMIT</code>.</p>"},{"location":"extensions/#building-an-extension-from-source","title":"\ud83d\udee0\ufe0f Building an Extension from Source","text":"<p>Some extensions (like pgjwt) must be compiled manually.</p>"},{"location":"extensions/#1-clone-the-extension-source","title":"1. Clone the Extension Source","text":"<pre><code>git clone https://github.com/michelp/pgjwt postgres/pgjwt\n</code></pre>"},{"location":"extensions/#2-modify-the-postgres-dockerfile","title":"2. Modify the Postgres Dockerfile","text":"<p>Edit <code>postgres/Dockerfile</code> to install build tools and compile the extension:</p> <pre><code>RUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    postgresql-server-dev-17\n\n# pgjwt - used by the auth schema\nCOPY ./pgjwt /pgjwt\nWORKDIR /pgjwt\nRUN make &amp;&amp; make install\n\n# Reset workdir\nWORKDIR /var/lib/postgresql\n</code></pre> <p>\ud83e\uddfc Set <code>WORKDIR</code> back to the default to avoid unintended effects.</p>"},{"location":"extensions/#3-rebuild-the-container","title":"3. Rebuild the Container","text":"<pre><code>docker compose build postgres\n</code></pre> <p>That\u2019s it \u2014 the extension is now available to load in your migrations.</p>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"<p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/explodinglabs/superstack myapp\ncd myapp\n</code></pre>"},{"location":"gettingstarted/#2-configure-your-environment","title":"2. Configure Your Environment","text":"<p>Copy the example environment file:</p> <pre><code>cp example.env .env\n</code></pre> <p>\ud83d\udca1 The <code>.env</code> file is for local development only. For remote deployments, set secrets via CI/CD or with <code>docker compose --env</code> (avoid leaking secrets to shell history).</p>"},{"location":"gettingstarted/#3-start-superstack","title":"3. Start SuperStack","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is live.</p> <p>You can now open localhost:8000/openapi/ to explore your API.</p>"},{"location":"gettingstarted/#what-just-happened","title":"\ud83e\udde9 What Just Happened?","text":"<p>SuperStack automatically:</p> <ul> <li>Starts a fresh Postgres database</li> <li>Applies initial migrations</li> <li>Launches PostgREST and Swagger UI</li> <li>Serves everything through Caddy on http://localhost:8000</li> </ul> <pre><code>flowchart TD\n    Caddy[\"Caddy (API Gateway)\"]\n    Caddy --&gt; Services[\"Services (PostgREST, Swagger UI + more)\"]\n    Services --&gt; Postgres\n</code></pre> <p>\ud83d\udca1 Only Caddy exposes a port \u2013 all services are routed through it.</p>"},{"location":"gettingstarted/#nuke-everything","title":"Nuke everything","text":"<p>To wipe your stack and start clean:</p> <pre><code>docker compose down --volumes\n</code></pre>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Create your database schema and migrations \ud83d\udc49 Deploy to a remote environment</p>"},{"location":"migrations/","title":"\ud83d\udcdc Migrations","text":"<p>SuperStack includes a simple built-in system for managing database schema migrations.</p>"},{"location":"migrations/#writing-migrations","title":"\u270d\ufe0f Writing Migrations","text":"<p>Place your migration scripts in:</p> <pre><code>postgres/migrations/\n</code></pre> <p>Each file should be:</p> <ul> <li>A <code>.sql</code> file</li> <li>Numbered in order (e.g. <code>00-init.sql</code>, <code>01-extensions.sql</code>, <code>02-auth.sql</code>)</li> <li>Written in plain SQL</li> <li>But can include environment variables.</li> </ul>"},{"location":"migrations/#transactions","title":"\ud83d\udd01 Transactions","text":"<p>Each migration file should start with <code>BEGIN</code> and end with <code>COMMIT</code>, like this:</p> <pre><code>-- File: postgres/migrations/03-create_table_example.sql\nbegin;\n\ncreate table example (\n  id serial primary key,\n  name text not null\n);\n\ncommit;\n</code></pre>"},{"location":"migrations/#non-transactional-migrations","title":"\u26a0\ufe0f Non-Transactional Migrations","text":"<p>Some statements (like create extension) cannot be wrapped in a transaction. In those cases, skip the <code>BEGIN/COMMIT</code>:</p> <pre><code>-- File: postgres/migrations/02-extensions.sql\ncreate extension pgcrypto;\n</code></pre>"},{"location":"migrations/#applying-migrations","title":"\u25b6\ufe0f Applying Migrations","text":"<p>To apply your migrations, run:</p> <pre><code>bin/postgres migrate\n</code></pre> <p>This will:</p> <ul> <li>Check for a <code>.applied_migrations</code> file inside the container</li> <li>Run any migration files that haven\u2019t been applied yet (in filename order)</li> <li>Record each successfully applied file in <code>.applied_migrations</code></li> </ul> <p>\ud83d\udca1 Already-applied scripts are skipped on subsequent runs.</p>"},{"location":"migrations/#first-time-setup","title":"\ud83e\uddea First-Time Setup","text":"<p>When the Postgres container starts with no existing data, SuperStack will automatically run migrations once.</p> <p>This happens during initial startup \u2014 no manual step needed.</p> <p>After the first <code>docker compose up</code>, migrations will only run if you run <code>bin/postgres migrate</code>.</p>"},{"location":"migrations/#resetting","title":"\ud83d\udd04 Resetting","text":"<p>If you want to start fresh:</p> <pre><code>docker compose down --volumes\n</code></pre> <p>Then:</p> <pre><code>docker compose up\n</code></pre> <p>This will wipe your database and re-run all migrations from scratch.</p>"},{"location":"psql/","title":"\ud83d\udda5\ufe0f Using psql","text":"<p><code>psql</code> is the command-line tool for interacting with your PostgreSQL database. SuperStack makes it easy to run psql inside the container using a helper script.</p>"},{"location":"psql/#open-a-psql-shell","title":"\ud83d\udcdf Open a psql Shell","text":"<p>To connect interactively:</p> <pre><code>bin/postgres psql\n</code></pre> <p>Example output:</p> <pre><code>psql (17.5 (Debian 17.5-1.pgdg120+1))\nType \"help\" for help.\n\napp=#\n</code></pre>"},{"location":"psql/#run-inline-sql-commands","title":"\ud83d\udd39 Run Inline SQL Commands","text":"<p>You can also run SQL directly from the command line:</p> <pre><code>bin/postgres psql -c 'select version()'\n</code></pre> <p>Example output:</p> <pre><code>                                                       version\n---------------------------------------------------------------------------------------------------------------------\n PostgreSQL 17.5 (Debian 17.5-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit\n(1 row)\n</code></pre>"},{"location":"psql/#customize-psql-behavior","title":"\u2699\ufe0f Customize psql Behavior","text":"<p>You can persist your preferences using <code>.psqlrc</code> and <code>.inputrc</code>.</p>"},{"location":"psql/#step-1-create-a-config-directory","title":"\ud83d\udd27 Step 1: Create a config directory","text":"<pre><code>mkdir -p postgres/rc\n</code></pre>"},{"location":"psql/#psqlrc","title":"\ud83d\udcc4 .psqlrc","text":"<p>Create <code>postgres/rc/.psqlrc</code> with your preferred settings:</p> <pre><code>\\pset pager off\n\\setenv PAGER 'less -S'\n</code></pre> <p>See the official psql reference for all available options.</p>"},{"location":"psql/#inputrc","title":"\ud83d\udcc4 .inputrc","text":"<p>Create <code>postgres/rc/.inputrc</code> to set readline behavior:</p> <pre><code>set editing-mode vi\n</code></pre>"},{"location":"psql/#step-2-mount-and-apply-the-configs","title":"\ud83d\udd17 Step 2: Mount and apply the configs","text":"<p>Add to your <code>compose.override.yaml</code>:</p> <pre><code>services:\n  postgres:\n    volumes:\n      - ./postgres/rc:/rc:ro\n    environment:\n      PSQLRC: /rc/.psqlrc\n      INPUTRC: /rc/.inputrc\n</code></pre>"},{"location":"psql/#step-3-restart-the-postgres-container","title":"\ud83d\udd01 Step 3: Restart the Postgres container","text":"<pre><code>docker compose down postgres\ndocker compose up -d postgres\n</code></pre>"}]}